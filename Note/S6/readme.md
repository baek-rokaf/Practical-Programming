## Section6: 연산자 2

### 49. 비트 연산자

- 비트(bitwise) 연산자
  - 이진수 피연산자를 비트 단위로 연산할 때 사용
    - &(and)
    - |(or)
    - ^(xor)
    - ~(not)
---
- &(and)연산자
  ```cs
  int op1 = 12; //1100
  int op2 = 9; //1001
  int andResult = op1 & op2; //1000 -> 8
  ```
- |(or)연산자
  ```cs
  int op1 = 12; //1100
  int op2 = 9; //1001
  int orResult = op1 | op2; //1101 -> 8 + 4 + 1 = 13
  ```
- ^(xor)연산자; 교집합 제외
  ```cs
  int op1 = 12; //1100
  int op2 = 9; //1001
  int xorResult = op1 ^ op2; //0101 ->  4 + 1 = 5
  ```

- ~(not)연산자
  ```cs
  int op1 = 12; //0000 0000 0000 0000 0000 0000 0000 1100
  int notResult = ~op1; //1111 1111 1111 1111 1111 1111 1111 0011 = -13
  ```

---
### 50. 51. 비트 이동 연산자

- 비트 이동(bit shift) 연산자
  - 비트를 왼쪽 혹은 오른쪽으로 움직이는 연산자들
    - <<(left-shift)
    - \>>(right-shift)
---
- <<(left-shift) 연산자
  - 가장 좌측의 비트는 버려짐
  - 가장 우측의 비트는 0으로 채워짐
```cs
int op1 = 12; //0000...0000 1100

int leftShiftResult1 = op1 << 1; // 0001 1000 = 24(2배)
int leftShiftResult2 = op1 << 2; // 0011 0000 = 48(2^2배)
```

- \>>(right-shift) 연산자
  - 가장 우측의 비트는 버려짐
  - 가장 좌측의 비트는 0으로 채워짐
```cs
int op1 = 12; //0000...0000 1100

int rightShiftResult0 = op1 >> 2; // 0000 0011 = 3 (2^2로 나눈 몫)
int rightShiftResult1 = op1 >> 3; // 0000 0001 = 1
int righthiftResult2 = op1 >> 4; // 0000 0000 = 0
```

---
### 52. 코드보기: 비트 이동 연산자로 2씩 곱하고 나누기

---
### 53. 코드보기: 비트플래그

---
### 54. 대입 연산자

---
### 55. 그 밖의 연산자

---
### 56. 정리